<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: GDS Integration Test API User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">F´ Flight Software - C/C++ Documentation<span id="projectnumber">&#160;devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_fprime_2docs_2documentation_2user-manual_2gds_2user__guide.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">GDS Integration Test API User Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md341"></a></p>
<p>The GDS integration test API is a tool that provides useful functions and asserts for creating integration or system tests for an F´ deployment. These tests run through the ground system attached to a running F´ deployment. This document hopes to give an overview of the main features associated with the Test API and demonstrates common use patterns and highlight some anti-patterns.</p>
<p>This integration test API was developed by Kevin Oran in the summer of 2019.</p>
<h1><a class="anchor" id="autotoc_md342"></a>
Quick Start</h1>
<p>Integration tests are implemented using <a href="https://docs.pytest.org/">pytest</a> a custom fixture called <code>fprime_test_api</code> is provided that configures <code>pytest</code> to attach to the GDS framework, and provides access to the API functions.</p>
<p>To create a simple test, place the following function in a python file in <code>test/int/test_my_deployment.py</code> typically in your deployment folder.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_send_command(fprime_test_api):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot; Ensure commanding works as expected</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    Tests that commands may be sent and the expected command severity events are returned.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    fprime_test_api.send_and_assert_command(<span class="stringliteral">&quot;cmdDisp.CMD_NO_OP&quot;</span>, max_delay=0.1)</div>
<div class="line">    <span class="keyword">assert</span> fprime_test_api.get_command_test_history().size() == 1</div>
</div><!-- fragment --><p>To run this test, ensure the GDS is running (by invoking <code>fprime-gds</code>) and then run <code>pytest test/int/test_my_deployment.py</code>.</p>
<p>!!! note You must ensure that your deployment has been built as this is required by <code>fprime-gds</code> and the integration test API.</p>
<h1><a class="anchor" id="autotoc_md343"></a>
Usage Patterns</h1>
<p>All usage patterns are written such that they would be compatible with the test framework example described above: each test case assumes that the histories were recently emptied and that the <code>fprime_test_api</code> is provided as a pytest fixture. You may also browse sample <a href="https://github.com/nasa/fprime/blob/devel/Ref/test/int/ref_integration_test.py">Ref app integration tests</a>.</p>
<h2><a class="anchor" id="autotoc_md344"></a>
Sending Commands</h2>
<p>The Integration Test API provides several methods for sending commands. The most simple is the <code>send_command</code> method.</p>
<p>!!! note The command arguments must be Python strings (str) instead of a literal.</p>
<div class="fragment"><div class="line">fprime_test_api.send_command(<span class="stringliteral">&quot;TEST_CMD_1&quot;</span>) <span class="comment"># sending a command via mnemonic</span></div>
<div class="line">fprime_test_api.send_command(0x01)         <span class="comment"># sending the same command via opcode</span></div>
<div class="line"> </div>
<div class="line">fprime_test_api.send_command(<span class="stringliteral">&quot;TEST_CMD_2&quot;</span>, [<span class="stringliteral">&quot;235&quot;</span>, <span class="stringliteral">&quot;43&quot;</span>]) <span class="comment"># sending a command with arguments</span></div>
</div><!-- fragment --><p>These calls do not ensure that command severity events were seen they just ensure that the command was sent. To do both users should use <code>send_and_assert_command</code> with a <code>max_delay</code> of the time to wait for those events</p>
<div class="fragment"><div class="line">fprime_test_api.send_and_assert_command(<span class="stringliteral">&quot;TEST_CMD_2&quot;</span>, [<span class="stringliteral">&quot;235&quot;</span>, <span class="stringliteral">&quot;43&quot;</span>], max_delay=0.1)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md345"></a>
Searching for Telemetry</h2>
<p>The integration Test API provides several different types of searches. Using a telemetry_predicate will enable the user to better specify the fields of the ChData object to be searched for.</p>
<p>!!! note all searches in the API will return the results of the search. This is so the user may perform additional checks on the results. Whether the search was successful is left to the user to check.</p>
<div class="fragment"><div class="line"><span class="comment"># awaits a telemetry update on the Counter Channel</span></div>
<div class="line">result = fprime_test_api.await_telemetry(<span class="stringliteral">&quot;Counter&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># same search, but using an id</span></div>
<div class="line">result = fprime_test_api.await_telemetry(3)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># awaits a Counter update with a value of 8</span></div>
<div class="line">result = fprime_test_api.await_telemetry(<span class="stringliteral">&quot;Counter&quot;</span>, 8)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># searches for an existing telemetry update on the Counter Channel</span></div>
<div class="line">result = fprime_test_api.await_telemetry(<span class="stringliteral">&quot;Counter&quot;</span>, start=0, timeout=0)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># awaits for 7 telemetry updates that are not guaranteed to be in order</span></div>
<div class="line">results = fprime_test_api.await_telemetry_count(7, <span class="stringliteral">&quot;Counter&quot;</span>)</div>
<div class="line"> </div>
<div class="line">ch_seq = []</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0,10):</div>
<div class="line">    ch_seq.append(fprime_test_api.get_telemetry_pred(<span class="stringliteral">&quot;Counter&quot;</span>, i))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># awaits for 10 Counter updates with the values 0 through 9 (inclusive).</span></div>
<div class="line"><span class="comment"># the resulting sequence must follow the history&#39;s enforced order</span></div>
<div class="line">results = fprime_test_api.await_telemetry_sequence(ch_seq)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md346"></a>
Asserting on Telemetry</h2>
<p>The integration Test API provides several different types of searches that can be followed by an assert on whether the search succeeded. Using a telemetry_predicate will enable the user to better specify the fields of the ChData object to be searched for.</p>
<p>!!! note all successful search-then-assert calls in the API will return the results of the search. This is so the user may perform additional checks on the results. Because an assertion is raised on search failure, the user can be sure the results reflect a successful test.</p>
<div class="fragment"><div class="line"><span class="comment"># asserts a telemetry update exists in the current history</span></div>
<div class="line">result = fprime_test_api.assert_telemetry(<span class="stringliteral">&quot;Counter&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># same search, but using an id</span></div>
<div class="line">result = fprime_test_api.assert_telemetry(3)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># asserts a &quot;Counter&quot; update with a value of 8 exists in the current history</span></div>
<div class="line">result = fprime_test_api.assert_telemetry(<span class="stringliteral">&quot;Counter&quot;</span>, 8)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># awaits and asserts a &quot;Counter&quot; update was received</span></div>
<div class="line">result = fprime_test_api.assert_telemetry(<span class="stringliteral">&quot;Counter&quot;</span>, start=<span class="stringliteral">&quot;END&quot;</span>, timeout=5)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># asserts a count of exactly 7 &quot;Counter&quot; updates exist in the current history</span></div>
<div class="line">results = fprime_test_api.assert_telemetry_count(7, <span class="stringliteral">&quot;Counter&quot;</span>)</div>
<div class="line"> </div>
<div class="line">ch_seq = []</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0,10):</div>
<div class="line">    ch_seq.append(fprime_test_api.get_telemetry_pred(<span class="stringliteral">&quot;Counter&quot;</span>, i))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># asserts the history contains a sequence of &quot;Counter&quot; updates with vals 0 through 9</span></div>
<div class="line"><span class="comment"># the resulting sequence must follow the history&#39;s enforced order</span></div>
<div class="line">results = fprime_test_api.assert_telemetry_sequence(ch_seq)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md347"></a>
Searching for Events</h2>
<p>The integration Test API provides several different types of searches. Using an event_predicate will enable the user to better specify the fields of the EventData object to be searched for.</p>
<p>!!! note all searches in the API will return the results of the search. This is so the user may perform additional checks on the results. Whether the search was successful is left to the user to check.</p>
<div class="fragment"><div class="line"><span class="comment"># awaits a &quot;CommandReceived&quot; event</span></div>
<div class="line">result = fprime_test_api.await_event(<span class="stringliteral">&quot;CommandReceived&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># same search, but using an id</span></div>
<div class="line">result = fprime_test_api.await_event(0x01)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># awaits a &quot;CommandReceived&quot; event with arguments that match</span></div>
<div class="line">result = fprime_test_api.await_event(<span class="stringliteral">&quot;CommandReceived&quot;</span>, [0x01])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># searches for an existing &quot;CommandReceived&quot; event</span></div>
<div class="line">result = fprime_test_api.await_event(<span class="stringliteral">&quot;CommandReceived&quot;</span>, start=0, timeout=0)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># awaits for any 7 events updates that are not guaranteed to be in order</span></div>
<div class="line">results = fprime_test_api.await_event_count(7)</div>
<div class="line"> </div>
<div class="line">evr_seq = []</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0,10):</div>
<div class="line">    evr_seq.append(fprime_test_api.get_event_pred(<span class="stringliteral">&quot;CommandReceived&quot;</span>, [i]))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># awaits for 10 &quot;CommandReceived&quot; events with the argument values 0 through 9 (inclusive).</span></div>
<div class="line"><span class="comment"># the resulting sequence must follow the history&#39;s enforced order</span></div>
<div class="line">results = fprime_test_api.await_event_sequence(evr_seq)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md348"></a>
Asserting on Events</h2>
<p>The integration Test API provides several different types of searches that can be followed by an assert on whether the search succeeded. Using an event_predicate will enable the user to better specify the fields of the EventData object to be searched for.</p>
<p>!!! note all successful search-then-assert calls in the API will return the results of the search. This is so the user may perform additional checks on the results. Because an assertion is raised on search failure, the user can be sure the results reflect a successful test.</p>
<div class="fragment"><div class="line"><span class="comment"># asserts a &quot;CommandReceived&quot; event is in the history</span></div>
<div class="line">result = fprime_test_api.assert_event(<span class="stringliteral">&quot;CommandReceived&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># same search, but using an id</span></div>
<div class="line">result = fprime_test_api.assert_event(0x01)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># asserts a &quot;CommandReceived&quot; event with arguments is in the history</span></div>
<div class="line">result = fprime_test_api.assert_event(<span class="stringliteral">&quot;CommandReceived&quot;</span>, [0x01])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># awaits and asserts on a single &quot;CommandReceived&quot; event</span></div>
<div class="line">result = fprime_test_api.assert_event(<span class="stringliteral">&quot;CommandReceived&quot;</span>, start=<span class="stringliteral">&quot;END&quot;</span>, timeout=5)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># asserts that exactly 7 of any event are in the history</span></div>
<div class="line">results = fprime_test_api.assert_event_count(7)</div>
<div class="line"> </div>
<div class="line">evr_seq = []</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(0,10):</div>
<div class="line">    evr_seq.append(fprime_test_api.get_event_pred(<span class="stringliteral">&quot;CommandReceived&quot;</span>, [i]))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># asserts tha history has a sequence of 10 &quot;CommandReceived&quot; events with the argument vals 0 through 9 (inclusive).</span></div>
<div class="line"><span class="comment"># the resulting sequence must follow the history&#39;s enforced order</span></div>
<div class="line">results = fprime_test_api.assert_event_sequence(evr_seq)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md349"></a>
Sending and Searching/Asserting</h2>
<p>The Test API provides 4 versions of send and search to enable searching for telemetry and events following a command. Internally, these calls record the current position of the history, then send a command then begin a search from the recorded position. All 4 versions support both item and sequence searches depending on whether the channels/events arguments are a list.</p>
<div class="fragment"><div class="line"># sends &quot;TEST_CMD_1&quot; then awaits a &quot;CommandCounter&quot; channel update</div>
<div class="line">result = fprime_test_api.send_and_await_telemetry(&quot;TEST_CMD_1&quot;, channels=&quot;CommandCounter&quot;)</div>
<div class="line"> </div>
<div class="line"># sends &quot;TEST_CMD_1&quot; then awaits a sequence of &quot;CommandCounter&quot; then five &quot;Counter&quot; updates</div>
<div class="line">seq = [&quot;CommandCounter&quot;] + [&quot;Counter&quot;] * 5</div>
<div class="line">results = fprime_test_api.send_and_await_telemetry(&quot;TEST_CMD_1&quot;, channels=seq)</div>
<div class="line"> </div>
<div class="line"># sends &quot;TEST_CMD_1&quot; then awaits and asserts a &quot;CommandCounter&quot; channel update</div>
<div class="line">result = fprime_test_api.send_and_assert_telemetry(&quot;TEST_CMD_1&quot;, channels=&quot;CommandCounter&quot;)</div>
<div class="line"> </div>
<div class="line"># sends &quot;TEST_CMD_1&quot; then awaits a &quot;CommandReceived&quot; event</div>
<div class="line">result = fprime_test_api.send_and_await_event(&quot;TEST_CMD_1&quot;, events=&quot;CommandReceived&quot;)</div>
<div class="line"> </div>
<div class="line"># sends &quot;TEST_CMD_1&quot; then awaits a sequence of &quot;CommandReceived&quot; then five &quot;SeverityDIAGNOSTIC&quot; events</div>
<div class="line">seq = [&quot;CommandReceived&quot;] + [&quot;SeverityDIAGNOSTIC&quot;] * 5</div>
<div class="line">results = fprime_test_api.send_and_await_event(&quot;TEST_CMD_1&quot;, events=seq)</div>
<div class="line"> </div>
<div class="line"># sends &quot;TEST_CMD_1&quot; then awaits and asserts &quot;CommandReceived&quot; event</div>
<div class="line">result = fprime_test_api.send_and_assert_event(&quot;TEST_CMD_1&quot;, events=&quot;CommandReceived&quot;)</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;Unlike <code>send_and_assert_command</code> command severity events are not automatically checked with these commands. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md350"></a>
Using predicates</h2>
<p>The API uses predicates to identify valid values in searches and filter data objects into histories. The provided predicates can be combined to make specifying an event message or channel update incredibly flexible. When using predicates, it is important to understand that a predicate is used to determine if a value belongs to a set of values that satisfies a rule. Not satisfying a rule **DOES NOT** imply that a value satisfies a second complementary rule.</p>
<h3><a class="anchor" id="autotoc_md351"></a>
Combining Predicates</h3>
<p>One pattern is to have multiple predicate specifications and want to combine these.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime_gds.common.testing_fw <span class="keyword">import</span> predicates</div>
<div class="line"> </div>
<div class="line">gt_pred = predicates.greater_than(8)</div>
<div class="line">eq_pred = predicates.equal_to(<span class="stringliteral">&quot;some_string&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># satisfies any will evaluate true if any of it&#39;s predicates are valid</span></div>
<div class="line">or_pred = predicates.satisfies_any([gt_pred, eq_pred])</div>
<div class="line"> </div>
<div class="line">or_pred(121)           <span class="comment"># evaluates True</span></div>
<div class="line">or_pred(<span class="stringliteral">&quot;some_string&quot;</span>) <span class="comment"># evaluates True</span></div>
<div class="line"> </div>
<div class="line">rng_pred = predicates.within_range(0, 100)</div>
<div class="line">ne_pred = predicates.not_equal_to(50)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># a valid value must be within the range 0 to 100 and must not be 50.</span></div>
<div class="line">and_pred = predicates.satisfies_all([rng_pred, ne_pred])</div>
<div class="line"> </div>
<div class="line">or_pred(15) <span class="comment"># evaluates True</span></div>
<div class="line">or_pred(50) <span class="comment"># evaluates False</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md352"></a>
Set Predicates</h3>
<p>Another pattern is to specify a collection and check if the value is a member of that collection.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime_gds.common.testing_fw <span class="keyword">import</span> predicates</div>
<div class="line"> </div>
<div class="line">is_in_pred = predicates.is_a_member_of([<span class="stringliteral">&quot;A&quot;</span>, 2, <span class="keyword">False</span>])</div>
<div class="line">isnt_in_pred = predicates.is_not_a_member_of([<span class="stringliteral">&quot;A&quot;</span>, 3])</div>
<div class="line"> </div>
<div class="line">is_in_pred(2)     <span class="comment"># evaluates True</span></div>
<div class="line">is_in_pred(<span class="keyword">False</span>) <span class="comment"># evaluates True</span></div>
<div class="line"> </div>
<div class="line">is_in_pred(<span class="stringliteral">&quot;A&quot;</span>)   <span class="comment"># evaluates True</span></div>
<div class="line">isnt_in_pred(<span class="stringliteral">&quot;A&quot;</span>) <span class="comment"># evaluates False</span></div>
</div><!-- fragment --><p>This pattern is useful for creating filters. For example, if we want to search or filter for certain event severities.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime_gds.common.testing_fw <span class="keyword">import</span> predicates</div>
<div class="line"><span class="keyword">from</span> fprime_gds.common.utils.event_severity <span class="keyword">import</span> EventSeverity</div>
<div class="line"> </div>
<div class="line">severities = []</div>
<div class="line">severities.append(EventSeverity.FATAL)</div>
<div class="line">severities.append(EventSeverity.WARNING_HI)</div>
<div class="line">sev_pred = predicates.is_a_member_of(severities)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># event pred will now identify any event with either Fatal or HI Warning severity</span></div>
<div class="line">event_pred = fprime_test_api.get_event_pred(severity=sev_pred)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md353"></a>
Specifying data objects</h3>
<p>The test API has two methods to help create event and telemetry predicates: <code>api.get_telemetry_pred</code> and <code>api.get_event_pred</code>. These methods overload argument types such that fields can be specified as a value (becomes an equal_to predicate) or they can be specified by user-created predicates. To specify the type of event/telemetry, the helpers can accept both mnemonics (str) or ids (int).</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime_gds.common.testing_fw <span class="keyword">import</span> predicates</div>
<div class="line"><span class="keyword">from</span> fprime_gds.common.utils.event_severity <span class="keyword">import</span> EventSeverity</div>
<div class="line"> </div>
<div class="line"><span class="comment"># both predicates will now identify any event with a command severity</span></div>
<div class="line">sev_pred = predicates.equal_to(EventSeverity.COMMAND)</div>
<div class="line">event_pred1 = fprime_test_api.get_event_pred(severity=sev_pred)</div>
<div class="line">event_pred2 = fprime_test_api.get_event_pred(severity=EventSeverity.COMMAND)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># both predicates will now identify any &quot;CommandCounter&quot; Update</span></div>
<div class="line">ch_pred1 = fprime_test_api.get_telemetry_pred(<span class="stringliteral">&quot;CommandCounter&quot;</span>)</div>
<div class="line">ch_pred2 = fprime_test_api.get_telemetry_pred(1)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md354"></a>
Using sub-histories</h2>
<p>One pattern that the API supports is creating a sub-history of telemetry or event objects. There are several behaviors to understand with sub-histories that are outlined in the API features section. Below is an example of how to create sub-histories, search on sub-histories, and remove sub-histories. Sub-histories can be created for both telemetry and event data objects.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime_gds.common.testing_fw <span class="keyword">import</span> predicates</div>
<div class="line"><span class="keyword">from</span> fprime_gds.common.utils.event_severity <span class="keyword">import</span> EventSeverity</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Creates an event sub-history with the default object ordering (fsw_order).</span></div>
<div class="line">fsw_subhist = fprime_test_api.get_event_subhistory()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Creates a filtered sub-history with all events of COMMAND severity</span></div>
<div class="line">event_filter = fprime_test_api.get_event_pred(severity=EventSeverity.COMMAND)</div>
<div class="line">filt_subhist = fprime_test_api.get_event_subhistory(event_filter)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Creates an event sub-history with ERT ordering</span></div>
<div class="line">ert_subhist = fprime_test_api.get_event_subhistory(fsw_order=<span class="keyword">False</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Substitutes a sub-history into an API assert</span></div>
<div class="line">result = fprime_test_api.assert_event(<span class="stringliteral">&quot;SeverityCOMMAND&quot;</span>, history=filt_subhist)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># If a sub-history hasn&#39;t been removed. It can also be awaited on.</span></div>
<div class="line">results = fprime_test_api.await_event_count(5, history=fsw_subhist)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># De-register a sub-history from the GDS</span></div>
<div class="line">fprime_test_api.remove_event_subhistory(ert_subhist)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md355"></a>
Search returns</h2>
<p>API calls that perform a search and do not end by raising an Assertion Error will return the results of the search. This is so that the user can find some event or channel updates then perform additional checks on the results or use the results to specify a future search.</p>
<p>Here is an example of awaiting a counter sequence and verifying that the sequence always ascends.</p>
<div class="fragment"><div class="line">search_seq = [<span class="stringliteral">&quot;Counter&quot;</span>] * 5</div>
<div class="line">results = fprime_test_api.await_telemetry_sequence(search_seq)</div>
<div class="line"> </div>
<div class="line">last = <span class="keywordtype">None</span></div>
<div class="line"><span class="keywordflow">for</span> update <span class="keywordflow">in</span> results:</div>
<div class="line">    <span class="keywordflow">if</span> last <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="keyword">assert</span> update.get_val() &gt; last.get_val()</div>
<div class="line">    last = update</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md356"></a>
Assert Helpers</h2>
<p>Another feature provided to the user is the ability to raise asserts with formatted assert messages reflected in the test logs.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime_gds.common.testing_fw <span class="keyword">import</span> predicates</div>
<div class="line"> </div>
<div class="line"><span class="comment"># assert on values that can be evaluated as True or False</span></div>
<div class="line">fprime_test_api.test_assert(2 &lt; 3, <span class="stringliteral">&quot;The number two should be less than three&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># assert a predicate on a value the log message will be more descriptive.</span></div>
<div class="line">lt_pred = predicates.less_than(3)</div>
<div class="line">fprime_test_api.predicate_assert(lt_pred, 2, <span class="stringliteral">&quot;The number two should be less than three&quot;</span>)</div>
</div><!-- fragment --><p>Assert helpers can be configured not to raise an assertion error. They will also return True if the assertion passed or False if it failed. This can be used to perform multiple checks. This behavior is referred to as expecting instead of asserting.</p>
<div class="fragment"><div class="line"><span class="comment"># a variable to accumulate whether all checks were successful</span></div>
<div class="line">all_passed = <span class="keyword">True</span></div>
<div class="line">all_passed &amp;= fprime_test_api.test_assert(1 &lt; 3, <span class="stringliteral">&quot;1 should be less than 3&quot;</span>, expect=<span class="keyword">True</span>)</div>
<div class="line">all_passed &amp;= fprime_test_api.test_assert(2 &lt; 3, <span class="stringliteral">&quot;2 should be less than 3&quot;</span>, expect=<span class="keyword">True</span>)</div>
<div class="line"><span class="comment"># this call will not raise an assert, but will return False</span></div>
<div class="line">all_passed &amp;= fprime_test_api.test_assert(3 &lt; 3, <span class="stringliteral">&quot;3 should not be less than 3&quot;</span>, expect=<span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># checks that previous expectations passed.</span></div>
<div class="line">fprime_test_api.test_assert(all_passed, <span class="stringliteral">&quot;All checks should have passed, see log&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md357"></a>
Using TimeTypes</h2>
<p>The TimeType serializable stores timestamp information for both events and telemetry. As part of the development for the integration test API, the TimeType object was updated to support rich comparison and math operations. These are implemented with python special methods and are compatible with floating point numbers.</p>
<p>!!! note Math operations will return a new TimeType object with the resulting value and the TimeType serializable does not allow negative values.</p>
<p>!!! note Math operations between TimeType objects of different time_bases or time_context will return a TimeType with the same base and context as the left operand.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime.common.models.serialize.time_type <span class="keyword">import</span> TimeType</div>
<div class="line"> </div>
<div class="line">t0 = TimeType() <span class="comment"># 0.0 seconds</span></div>
<div class="line"> </div>
<div class="line">t1 = t0 + 1   <span class="comment"># Assigns a TimeType with a time of 1.0 seconds</span></div>
<div class="line">t3 = t0 + 3   <span class="comment"># Assigns a TimeType with a time of 3.0 seconds</span></div>
<div class="line">t2 = t3 - t1  <span class="comment"># Assigns a TimeType with a time of 2.0 seconds</span></div>
<div class="line">t0 = t1 - t3  <span class="comment"># Assigns a TimeType with a time of 0.0 seconds (negatives are set to 0)</span></div>
<div class="line">t15 = t3 / 2  <span class="comment"># Assigns a TimeType with a time of 1.5 seconds</span></div>
<div class="line">t6 =  t2 * t3 <span class="comment"># Assigns a TimeType with a time of 6.0 seconds</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">t1 &gt; 0   <span class="comment"># evaluates True</span></div>
<div class="line">t1 &gt; t0  <span class="comment"># evaluates True</span></div>
<div class="line">t6 == 6  <span class="comment"># evaluates True</span></div>
<div class="line">t3 &gt;= t2 <span class="comment"># evaluates True</span></div>
</div><!-- fragment --><p>Accessing TimeStamps from event and channel data types can be done with the <code>get_time()</code> getter. These comparisons can be very useful in testing whether FSW meets timing requirements.</p>
<div class="fragment"><div class="line">seq = [<span class="stringliteral">&quot;Counter&quot;</span>] * 5</div>
<div class="line">results = fprime_test_api.await_telemetry_sequence(seq)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># checks that all adjacent elements in the sequence happened within 2 seconds of each other</span></div>
<div class="line">last = <span class="keywordtype">None</span></div>
<div class="line"><span class="keywordflow">for</span> result <span class="keywordflow">in</span> results:</div>
<div class="line">    <span class="keywordflow">if</span> last <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="keyword">assert</span> result.get_time() - last.get_time() &lt; 2</div>
<div class="line">    last = result</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md358"></a>
Recording a point in the histories</h2>
<p>!!! bug There is an issue with how get_latest_time() is implemented. Getting history markers should be updated to be more robust.</p>
<p>If a user wants to record a marker, send some commands and then come back and evaluate items after that marker, then they can do the following: This all will return the latest FSW TimeStamp when the histories are ordered by FSW time.</p>
<div class="fragment"><div class="line"><span class="comment"># if using time-ordered histories</span></div>
<div class="line">fsw_start = fprime_test_api.get_latest_time()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># do some stuff</span></div>
<div class="line">fprime_test_api.send_command(<span class="stringliteral">&quot;TEST_CMD_1&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># search</span></div>
<div class="line">results = fprime_test_api.assert_telemetry(<span class="stringliteral">&quot;Counter&quot;</span>, start=fsw_start)</div>
</div><!-- fragment --><p>If using receive-ordered histories, this point should be marked as an index.</p>
<div class="fragment"><div class="line"><span class="comment"># if using re-ordered histories</span></div>
<div class="line">ro_start = fprime_test_api.get_telemetry_test_history().size()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># do some stuff</span></div>
<div class="line">fprime_test_api.send_command(<span class="stringliteral">&quot;TEST_CMD_1&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># search</span></div>
<div class="line">results = fprime_test_api.assert_telemetry(<span class="stringliteral">&quot;Counter&quot;</span>, start=ro_start)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md359"></a>
Anti-patterns</h1>
<p>These patterns do not operate as expected within the integration test API. You should ensure that you understand the issues using these patterns and perform them correctly.</p>
<h2><a class="anchor" id="autotoc_md360"></a>
Asserting none of a data object were received</h2>
<p>One thing a user might want to do is assert that no instances of a certain update or message were received. This can be done using a count search for zero items on <b>existing history items only</b>. This constraint is because the count search behaves as follows:</p>
<ol type="1">
<li>Count all items in the search scope of the current history</li>
<li>Await future updates until a correct count is received.</li>
</ol>
<p>So, if count search is awaiting zero items, it will exit immediately and claim success where the user may believe it searched future objects.</p>
<div class="fragment"><div class="line"><span class="comment"># incorrect, this will exit as the search found 0 items and was looking for 0 items</span></div>
<div class="line">fprime_test_api.assert_telemetry_count(0, start=<span class="stringliteral">&quot;END&quot;</span>, timeout=5)</div>
</div><!-- fragment --><p>If the user wants to assert that none of a certain type of object were received in the future scope, they should wait for items to accumulate then assert on existing scope.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> time</div>
<div class="line"> </div>
<div class="line"><span class="comment"># correct, way to say no telemetry was received in now or in the next 5 seconds.</span></div>
<div class="line">time.sleep(5)</div>
<div class="line">fprime_test_api.assert_telemetry_count(0)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md361"></a>
Specifying sequence searches with timestamps</h2>
<p>The doc-strings in the API recommend not specifying FSW timestamps when searching for sequences. This is simply because the timestamps can change depending on when tests are run. The easiest way to verify timing is to process timestamps after a search is completed.</p>
<h2><a class="anchor" id="autotoc_md362"></a>
No-scope search</h2>
<p>Because searches allow the user to define the existing and future scope to search, it is possible to completely de-scope a search.</p>
<div class="fragment"><div class="line"><span class="comment"># setting timeout to zero on await functions w/o a start, results in no scope</span></div>
<div class="line">fprime_test_api.await_telemetry_count(5, timeout=0)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># setting start to END on assert functions w/o a timeout, results in no scope</span></div>
<div class="line">fprime_test_api.assert_telemetry_count(5, start=<span class="stringliteral">&quot;END&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># setting start to END and timeout to zero on any search, results in no scope</span></div>
<div class="line">fprime_test_api.assert_telemetry_count(5, start=<span class="stringliteral">&quot;END&quot;</span>, timeout=0)</div>
<div class="line">fprime_test_api.await_telemetry_count(5, start=<span class="stringliteral">&quot;END&quot;</span>, timeout=0)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md363"></a>
Interpreting predicates correctly</h2>
<p>Predicates may compare a value to another, but their purpose isn't to compare two objects, rather to identify objects that satisfy a certain property or rule. If a user uses a greater_than predicate to see if a string is greater than a numeric value, 8, the predicate will return False. The correct interpretation is that the string is not in the set of values that are greater than 8. It is incorrect to say the string is less than 8.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime_gds.common.testing_fw <span class="keyword">import</span> predicates</div>
<div class="line"> </div>
<div class="line">gt_pred = predicates.greater_than(8)</div>
<div class="line">gt_pred(9)        <span class="comment"># evaluates True</span></div>
<div class="line">gt_pred(7)        <span class="comment"># evaluates False</span></div>
<div class="line">gt_pred(<span class="stringliteral">&quot;string&quot;</span>) <span class="comment"># evaluates False: String is not a value that is greater than 8</span></div>
<div class="line"> </div>
<div class="line">lte_pred = predicates.less_than_or_equal_to(8)</div>
<div class="line">lte_pred(8)        <span class="comment"># evaluates True</span></div>
<div class="line">lte_pred(7)        <span class="comment"># evaluates True</span></div>
<div class="line">lte_pred(<span class="stringliteral">&quot;string&quot;</span>) <span class="comment"># evaluates False: String is not a value that is less than 8</span></div>
</div><!-- fragment --><p><b>Takeaway</b>: using invert to try to convert a greater_then predicate to a less_than_or_equal_to predicate will introduce false positives if the user isn't aware of what a predicate is describing.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> fprime_gds.common.testing_fw <span class="keyword">import</span> predicates</div>
<div class="line"> </div>
<div class="line">gt_pred = predicates.greater_than(8)</div>
<div class="line">lte_pred = predicates.less_than_or_equal_to(8)</div>
<div class="line">not_lte_pred = predicates.invert(lte_pred) <span class="comment"># inverts how a predicate evaluates.</span></div>
<div class="line"> </div>
<div class="line">not_lte_pred(<span class="stringliteral">&quot;string&quot;</span>) <span class="comment"># evaluates True: because &quot;string&quot; is not a value that is less than 8</span></div>
<div class="line">gt_pred(<span class="stringliteral">&quot;string&quot;</span>) <span class="comment"># evaluates False: String is not a value that is greater than 8</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md364"></a>
Important API Features</h1>
<p>This section discusses important API features.</p>
<h2><a class="anchor" id="autotoc_md365"></a>
Specifying Search Scope (start and timeout arguments)</h2>
<p>All searches in the integration test API can be configured to search part of the existing history (Current Search Scope) and/or part of the future history (Future Search Scope). The API relies on two common variables to define the scope of what is searched: <code>start</code> and <code>timeout</code>.</p>
<p>The <code>start</code> argument specifies the Current Search Scope in an existing history. <code>start</code> is used to choose the earliest item that the search will evaluate in a given history's ordering. <code>start</code> can be either an index in the history's ordering, a predicate, or a TimeType timestamp. Because the Test API's histories support re-ordering, the TimeType timestamp is the most reliable marker for <code>start</code>. A predicate can also be used to specify a <code>start</code>. For example, if the assert is only to begin after a certain EVR was received then an event_predicate instance could be used to find the first element to search. If <code>start</code> is not specified, see the particular API function to learn the default behavior. For convenience, the API includes a member variable, <code>NOW</code>, that will begin the search after all existing history when <code>NOW</code> is passed as the <code>start</code> argument.</p>
<p>The <code>timeout</code> argument specifies the Future Search Scope (FSS) in seconds. FSS is how long a search should await until the search criteria is met. Searches that await a yet-to-be-received item can only specify how long in seconds. A <code>timeout</code> of zero seconds will skip awaiting at all.</p>
<p><img src="../../../img/APISearchScope.png" alt="Search Scope diagram" class="inline"/></p>
<p>All search methods can either be configured with CSS, FSS, or both.</p>
<div class="fragment"><div class="line"><span class="comment"># An example of FSS await 10 seconds</span></div>
<div class="line">fprime_test_api.await_telemetry_count(5, timeout=10)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># An example of CSS searching from the beginning of history</span></div>
<div class="line">fprime_test_api.assert_telemetry_count(5, start=0)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md366"></a>
Types of searches</h2>
<p>The integration test API defines three types of searches: item, count, and sequence. Each of these searches has an assert version and an await version as well as a version for both telemetry and event versions. This means the API has a total of 12 search calls.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Search Type   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">item search   </td><td class="markdownTableBodyLeft">an item search is searching for a specific item in the history. The result will return a single data object    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">count search   </td><td class="markdownTableBodyLeft">a count search is searching for a number of items in history. The result is a group of items that isn't necessarily ordered according to the history.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">sequence search   </td><td class="markdownTableBodyLeft">a sequence search is searching for an ordered sequence of items in the history. The result is an ordered list of items that is ordered with respect to the given history's order.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md367"></a>
Default Search Scope for await and assert calls</h3>
<p>The integration test API provides to versions of each type of search: the await version will always return results and the assert version will search and then assert on whether the search completed successfully. For any given combination of search type (item, count, sequence) and search behavior (await or assert), the API allows the user to reconfigure the search scope with CSS, FSS, or both. Because all search calls in the API can manipulate this scope, the API doesn't provide different combinations of search scopes as different API calls. However, the API does provide default arguments for its searches and name its searches accordingly. This was done to satisfy the common request to support await functionality explicitly even though this behavior is already being provided by all search types.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Prefix   </th><th class="markdownTableHeadLeft">Default Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>await_</code>   </td><td class="markdownTableBodyLeft">By default, all search-only calls begin with <code>await_</code> and will only search for future data objects for at most 5 seconds    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>assert_</code>   </td><td class="markdownTableBodyLeft">By default, all search and assert calls begin with <code>assert_</code> and will search all current data objects from the beginning of the history   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md368"></a>
Substituting a History With History Argument</h2>
<p>Another useful feature in the integration test API is the ability to create filtered sub-histories and substitute them into any regular API call. This feature provides the user with the ability to manage their own histories. The API methods that support this are<code>get_telemetry_subhistory</code>, <code>remove_telemetry_subhistory</code>, <code>get_event_subhistory</code>, <code>remove_event_subhistory</code>. There are several behaviors to know when creating sub-histories.</p>
<ul>
<li>When creating a sub-history, the get_ calls allow the user to specify whether the history will be ordered by receive order or by flight software time (FSW) order. This is done with the <code>fsw_order</code> argument (ordered by FSW time is default).</li>
<li>When creating a sub-history, the get_ calls allow the user to optionally specify a predicate filter to determine which items to allow into the sub-history (allows all by default). These filters should be a predicate composed of either telemetry_predicate's or event_predicate's depending on the type of sub-history.</li>
<li>A new subhistory WILL be registered with the GDS to automatically receive data objects from its respective decoder (event/telemetry).</li>
<li>A new subhistory will NOT be managed by the Test API. It will not be cleared nor de-registered when a test case ends.</li>
</ul>
<p>Removing a sub-history is currently permanent as the API doesn't provide for sub-histories to be re-registered. Removing a sub-history will unsubscribe it from the GDS and it will no longer receive new data objects.</p>
<h2><a class="anchor" id="autotoc_md369"></a>
Data object specifiers (event and channel arguments)</h2>
<p>Throughout the API specifying an event message or channel update to search for is very flexible. This is because all search types use predicates to specify a single or multiple objects when searching. The word used to describe this overloading behavior in the API is <code>specifier</code>. The phrases to look for in doc-strings are channel specifiers and event specifiers.</p>
<p>Providing this flexibility in the <code>event</code> and <code>channel</code> arguments is done via the get_event_predicate and get_telemetry_predicate calls. These calls provide argument-overloading when specifying different fields of ChData or EventData objects. The way this works for most fields is that if the user specifies the field as a value, the returned predicate will check that data object's corresponding field against that value; however, if the user specifies the field as a predicate, then the user's predicate will be called on that field instead. This enables using the predicates library to do more complex checks on certain fields.</p>
<p>In addition to specifying values by value or predicate, the get_event_predicate and get_telemetry_predicate calls also access the deployment dictionary to allow the user to specify a data object type by mnemonic or ID.</p>
<h2><a class="anchor" id="autotoc_md370"></a>
API Test Log</h2>
<p>When an output location is specified, the integration test API will generate a formatted test log as a .xlsx file. There are four columns in this file. They are summarized in the table below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Log Column   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Log Time   </td><td class="markdownTableBodyLeft">A time stamp of when the message was logged. Format "HH:mm:ss.us"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Case ID   </td><td class="markdownTableBodyLeft">An identifier for a test case. This field will help navigate when looking through long logs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Sender   </td><td class="markdownTableBodyLeft">Describes where the message originated (GDS, Test API, API user). Note: all log messages are still made through API calls.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Message   </td><td class="markdownTableBodyLeft">A string message recording test behavior.   </td></tr>
</table>
<p>The following image is an excerpt from an API log generated by the <a class="el" href="namespace_ref.html">Ref</a> App integration tests. <img src="../../../img/TestLogExample.png" alt="Test Log Example" class="inline"/></p>
<p>The following table summarizes the color meanings from API-generated messages.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Color   </th><th class="markdownTableHeadLeft">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Red   </td><td class="markdownTableBodyLeft">red indicates failed asserts. If a red log message is from the Test API, then an assertion error was raised by an API call.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Orange   </td><td class="markdownTableBodyLeft">orange indicates failed expectations and warnings.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Yellow   </td><td class="markdownTableBodyLeft">yellow indicates the beginning and end of any search.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Green   </td><td class="markdownTableBodyLeft">green indicates successful asserts and expectations within API calls.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Blue   </td><td class="markdownTableBodyLeft">blue indicates interlaced EVR's.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Purple   </td><td class="markdownTableBodyLeft">purple indicates commands that were sent to flight software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Gray   </td><td class="markdownTableBodyLeft">gray indicates the beginning of a new test case.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">White   </td><td class="markdownTableBodyLeft">white or blank fill is used for diagnostic messages.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md371"></a>
Predicates</h2>
<p>The integration test API uses predicates for filtering, searching and asserting. A predicate is a callable class that evaluates if an object/value satisfies a certain property. Predicates used by the API are defined <a href="https://github.com/fprime-community/fprime-gds/blob/devel/src/fprime_gds/common/testing_fw/predicates.py">here</a>. The API uses Duck Typing to determine what can and cannot be used as a predicate; therefore, a user of the API can very easily create their own. Below is a table of how predicates are organized with a brief summary of each section:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Predicate Section   </th><th class="markdownTableHeadLeft">Section Description   </th><th class="markdownTableHeadLeft">Functions/predicates    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Base class/helpers   </td><td class="markdownTableBodyLeft">This section contains the parent class for predicates and helpers to carry out duck-typing and string formatting.   </td><td class="markdownTableBodyLeft">class predicate, is_predicate(), get_descriptive_string()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Comparison Predicates   </td><td class="markdownTableBodyLeft">These predicates evaluate basic comparison rules (&lt;, =, &gt;, !=).   </td><td class="markdownTableBodyLeft">less_than, greater_than, equal_to, not_equal_to, less_than_or_equal_to, greater_than_or_equal_to, within_range    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Set Predicates   </td><td class="markdownTableBodyLeft">These predicates evaluate whether predicates belong to a set of objects.   </td><td class="markdownTableBodyLeft">is_a_member_of, is_not_a_member_of    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Logic Predicates   </td><td class="markdownTableBodyLeft">These predicates can be used to combine/manipulate other predicates with basic boolean logic.   </td><td class="markdownTableBodyLeft">always_true, invert (not), satisfies_all (and), satisfies_any (or)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Test API Predicates   </td><td class="markdownTableBodyLeft">These predicates operate specifically on the fields on the ChData and EventData objects. They are used by the API to specify event and telemetry messages.   </td><td class="markdownTableBodyLeft">args_predicate, event_predicate, telemetry_predicate   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md372"></a>
Known Bugs and Idiosyncrasies</h1>
<p>Known bugs and idiosyncrasies are tracked here: <a href="https://github.com/nasa/fprime/labels/Test%20API">Test API Issues</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
