<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Ground Interface Architecture and Customization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">F´ Flight Software - C/C++ Documentation<span id="projectnumber">&#160;devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_fprime_2docs_2documentation_2user-manual_2framework_2ground-interface.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Ground Interface Architecture and Customization</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md273"></a></p>
<p>This guide will discuss the F´ ground interface layers and how to customize them. There are two parts to the ground interface: the spacecraft side, and the ground side. This guide will primarily focus on the spacecraft side adaptation as the most common pattern is to adapt F´ flight software for some other ground system (e.g. <a href="https://github.com/BallAerospace/COSMOS">Cosmos</a>, <a href="https://nasa.github.io/openmct/">OpenMCT</a>, etc). This document will walk through common adaptations in hopes that projects will not need to replace the ground interface entirely.</p>
<p>In the most basic form, the F´ ground system pattern consists of two sides: uplink and downlink. These two sides each have two layers: framing and driver. Uplink handles data coming from the remote side of the interface, downlink handles data going to the remote interface, framing handles serializing and deserializing data to and from byte buffers, and the driver layer handles writing data to and from the hardware.</p>
<p><img src="../../../img/ground-interface.jpg" alt="Ground Interface Block Diagram" class="inline"/></p>
<p>Also of note is the framing protocol, which breaks out the handling of the byte serialization for quick adaptation. Each of these stages need to allocate memory and thus users should also consult the <a class="el" href="md_fprime_2docs_2documentation_2user-manual_2framework_2dynamic-memory.html">buffer management</a> guide.</p>
<p>!!! note in this guide we will refer to the driver layer but many projects will refer to it as the radio or communication layer. The function of this layer is to read and write bytes to some hardware and the nature of that hardware is irrelevant as long as it can send and receive bytes.</p>
<h1><a class="anchor" id="autotoc_md274"></a>
Ground Interface Architecture</h1>
<p>Standard F´ components handle two types of data: com buffers and raw buffers. Com buffers transmit standard F´ items (e.g. events, telemetry, and commands) whereas raw buffers (<code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code>) transmit any raw bytes like file data. Thus the F´ ground interface must handle both types of data. Communications hardware typically only transmits bytes of data and knows nothing about the nature of that data. The goal of the ground interfaces is to ensure that the various types of F´ data can be translated into a sequence of bytes that can be reconstructed on the other side of the interface. This architecture is described below.</p>
<h2><a class="anchor" id="autotoc_md275"></a>
Driver</h2>
<p>Drivers manage hardware communications. These can be simple hardware interfaces (e.g. TCP or UART) or far more complex constructs (e.g. radios, spacecraft buses). From the perspective of F´, the driver has two functions: provide incoming data and handle outgoing data.</p>
<p>!!! note typically projects use a single driver to handle both input and output, however; two drivers may be used to if differing behavior is needed for uplink and downlink.(e.g. UDP downlink for speed and Tcp uplink reliability).</p>
<p>All drivers implement an input port receiving data from the framer. The driver should write input data to the hardware the driver manages. Drivers implement at least one of two methods to retrieve data from hardware: an input port to poll for available data and an output read port for asynchronous data, which often is supported by a read thread. Generic drivers implement both such that they can be used in a threaded context or rate group-driven polling context. The driver is responsible for reading the data from the hardware in either context.</p>
<p>!!! note the F´ uplink layer is compatible with both polling and receiving drivers as described in <b>Uplink</b> below.</p>
<p><b>Sending Data</b></p>
<p>To send data to a driver, an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> is passed to the driver's send input port and the data wrapped by the buffer will be pushed out to the hardware. Drivers respond to sends with one of the following statuses:</p>
<ol type="1">
<li>SendStatus.SEND_OK: indicates the send was successful</li>
<li>SendStatus.SEND_RETRY: indicates subsequent retransmission will likely succeed</li>
<li>SendStatus.SEND_ERROR: send failed, the data was not sent, and future success cannot be predicted</li>
</ol>
<p><b>Polling Data</b></p>
<p>Polling for data allows the system to determine when to look for available data. This often means the driver does not need a thread constantly trying to read data. It is used in rate-group-driven baremetal systems to schedule the reception of data and remove the need for a task to spin looking for data. To poll data, an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> is passed to the driver's poll input port where the buffer is filled with available data. Polling returns the following statuses:</p>
<ol type="1">
<li>PollStatus.POLL_OK: indicates the buffer is filled with valid data</li>
<li>PollStatus.POLL_RETRY: indicates a subsequent retry of the polling call will likely result in valid data</li>
<li>PollStatus.POLL_ERROR: polling failed, the buffer data is invalid, and future success cannot be predicted</li>
</ol>
<p><b>Receiving Data</b></p>
<p>Receiving data is to handle asynchronous input of data without the need to poll for it. This typically means the driver has an internal task that calls the receive output port when data has been received. Receive ports are passed <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code>s and a receive status as described below. Receive RETRY status is not used as the external system has nothing to retry.</p>
<ol type="1">
<li>RecvStatus.RECV_OK: receive works as expected and the buffer has valid data</li>
<li>RecvStatus.RECV_ERROR: receive failed and the buffer does not have valid data</li>
</ol>
<h2><a class="anchor" id="autotoc_md276"></a>
Uplink</h2>
<p>Uplink handles received data, unpacks F´ data types, and routes these to the greater F´ system. In a typical formation, these com buffers are sent to the command dispatcher and raw buffers are sent to the file uplink. Uplink is implemented with the <a href="../api/c++/html/svc_deframer_component.html">Svc.Deframer</a> component. This component may be rate group driven in which case it polls for data or it may be driven by a driver's receive output port in which case it handles the data on that incoming port call. <a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc.Deframer</a> implements the <a href="../api/c++/html/class_svc_1_1_deframing_protocol_interface.html">DeframingProtocolInterface</a>.</p>
<p><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc.Deframer</a> unpacks F´ data from the supplied buffer using a <a href="../api/c++/html/class_svc_1_1_deframing_protocol.html">Svc::DeframingProtocol</a>, which calls back through the DeframingProtocolInterface to send deframed packets out to F´ components.</p>
<p>Internally, <a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc.Deframer</a> uses a circular buffer to store incoming data such that messages are not required to be complete. This buffer is updated with the latest data and then processed for messages on each poll or receiving of data.</p>
<h2><a class="anchor" id="autotoc_md277"></a>
Downlink</h2>
<p>Downlink takes in F´ data and wraps the data with bytes supporting the necessary protocol. This assembled data is then sent to the driver for handling. Downlink is implemented with the <a href="../api/c++/html/svc_framer_component.html">Svc.Framer</a> component, which implements the <a href="../api/c++/html/class_svc_1_1_framing_protocol_interface.html">FramingProtocolInterface</a>.</p>
<p><a class="el" href="class_svc_1_1_framer.html" title="Generic framing component using FramingProtocol implementation for actual framing.">Svc.Framer</a> packs F´ data using a <a href="../api/c++/html/class_svc_1_1_framing_protocol.html">Svc::FramingProtocol</a>, which calls back through the FramingProtocolInterface to send framed packets out to the driver.</p>
<h1><a class="anchor" id="autotoc_md278"></a>
Adding a Custom Wire Protocol</h1>
<p>To add a custom wire protocol an implementation needs to be written for two interfaces (virtual base classes). These are <a href="../api/c++/html/class_svc_1_1_framing_protocol.html">Svc::FramingProtocol</a> and <a href="../api/c++/html/class_svc_1_1_deframing_protocol.html">Svc::DeframingProtocol</a>.</p>
<p><a class="el" href="class_svc_1_1_framing_protocol.html" title="abstract class representing a framing protocol">Svc::FramingProtocol</a> implementors need to implement one function: frame, taking in a pointer to the data to frame, the size of the data, and a packet type for the data. The base class supplies a <a href="../api/c++/html/class_svc_1_1_framing_protocol_interface.html">FramingProtocolInterface</a> member variable, <code>m_interface</code>, that allows implementors to call out for allocating data and sending the newly framed data. A minimal implementation is:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>MyFrameProtocol : <span class="keyword">public</span> <a class="code hl_class" href="class_svc_1_1_framing_protocol.html">Svc::FramingProtocol</a> {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    MyFrameProtocol() {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_svc_1_1_framing_protocol.html#a987ab763ad6ea4087f025c90d7e7a835">frame</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="_basic_types_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a> *<span class="keyword">const</span> data, <span class="keyword">const</span> <a class="code hl_typedef" href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> size, <a class="code hl_enumeration" href="class_fw_1_1_com_packet.html#a715f7261d313574f50a43b12914db425">Fw::ComPacket::ComPacketType</a> packet_type) {</div>
<div class="line">        <a class="code hl_class" href="class_fw_1_1_buffer.html">Fw::Buffer</a> my_framed_data = m_interface.allocate(size);</div>
<div class="line">        my_framed_data.<a class="code hl_function" href="class_fw_1_1_buffer.html#af881c86bc7c3a7855009d0eb537f60d0">getSerializeRepr</a>().<a class="code hl_function" href="class_fw_1_1_serialize_buffer_base.html#ac7eef383cbb84ad69d09d036a7249cdf">serialize</a>(0xdeadbeef); <span class="comment">// Some start word</span></div>
<div class="line">        my_framed_data.<a class="code hl_function" href="class_fw_1_1_buffer.html#af881c86bc7c3a7855009d0eb537f60d0">getSerializeRepr</a>().<a class="code hl_function" href="class_fw_1_1_serialize_buffer_base.html#ac7eef383cbb84ad69d09d036a7249cdf">serialize</a>(size);       <span class="comment">// Write size</span></div>
<div class="line">        my_framed_data.<a class="code hl_function" href="class_fw_1_1_buffer.html#af881c86bc7c3a7855009d0eb537f60d0">getSerializeRepr</a>().<a class="code hl_function" href="class_fw_1_1_serialize_buffer_base.html#ac7eef383cbb84ad69d09d036a7249cdf">serialize</a>(data, size, <span class="keyword">true</span>); <span class="comment">// Data copied to buffer no length included</span></div>
<div class="line">        m_interface.send(my_framed_data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="a_basic_types_8h_html_aa63ef7b996d5487ce35a5a66601f3e73"><div class="ttname"><a href="_basic_types_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a></div><div class="ttdeci">uint8_t U8</div><div class="ttdoc">8-bit unsigned integer</div><div class="ttdef"><b>Definition</b> <a href="_basic_types_8h_source.html#l00026">BasicTypes.h:26</a></div></div>
<div class="ttc" id="abasic__types_8h_html_a696390429f2f3b644bde8d0322a24124"><div class="ttname"><a href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a></div><div class="ttdeci">uint32_t U32</div><div class="ttdef"><b>Definition</b> <a href="basic__types_8h_source.html#l00028">basic_types.h:28</a></div></div>
<div class="ttc" id="aclass_fw_1_1_buffer_html"><div class="ttname"><a href="class_fw_1_1_buffer.html">Fw::Buffer</a></div><div class="ttdef"><b>Definition</b> <a href="_buffer_8hpp_source.html#l00043">Buffer.hpp:43</a></div></div>
<div class="ttc" id="aclass_fw_1_1_buffer_html_af881c86bc7c3a7855009d0eb537f60d0"><div class="ttname"><a href="class_fw_1_1_buffer.html#af881c86bc7c3a7855009d0eb537f60d0">Fw::Buffer::getSerializeRepr</a></div><div class="ttdeci">SerializeBufferBase &amp; getSerializeRepr()</div><div class="ttdef"><b>Definition</b> <a href="_buffer_8cpp_source.html#l00107">Buffer.cpp:107</a></div></div>
<div class="ttc" id="aclass_fw_1_1_com_packet_html_a715f7261d313574f50a43b12914db425"><div class="ttname"><a href="class_fw_1_1_com_packet.html#a715f7261d313574f50a43b12914db425">Fw::ComPacket::ComPacketType</a></div><div class="ttdeci">ComPacketType</div><div class="ttdef"><b>Definition</b> <a href="_com_packet_8hpp_source.html#l00021">ComPacket.hpp:21</a></div></div>
<div class="ttc" id="aclass_fw_1_1_serialize_buffer_base_html_ac7eef383cbb84ad69d09d036a7249cdf"><div class="ttname"><a href="class_fw_1_1_serialize_buffer_base.html#ac7eef383cbb84ad69d09d036a7249cdf">Fw::SerializeBufferBase::serialize</a></div><div class="ttdeci">SerializeStatus serialize(U8 val)</div><div class="ttdoc">serialize 8-bit unsigned int</div><div class="ttdef"><b>Definition</b> <a href="_serializable_8cpp_source.html#l00065">Serializable.cpp:65</a></div></div>
<div class="ttc" id="aclass_svc_1_1_framing_protocol_html"><div class="ttname"><a href="class_svc_1_1_framing_protocol.html">Svc::FramingProtocol</a></div><div class="ttdoc">abstract class representing a framing protocol</div><div class="ttdef"><b>Definition</b> <a href="_framing_protocol_8hpp_source.html#l00031">FramingProtocol.hpp:31</a></div></div>
<div class="ttc" id="aclass_svc_1_1_framing_protocol_html_a987ab763ad6ea4087f025c90d7e7a835"><div class="ttname"><a href="class_svc_1_1_framing_protocol.html#a987ab763ad6ea4087f025c90d7e7a835">Svc::FramingProtocol::frame</a></div><div class="ttdeci">virtual void frame(const U8 *const data, const U32 size, Fw::ComPacket::ComPacketType packet_type)=0</div><div class="ttdoc">frame a given set of bytes</div></div>
</div><!-- fragment --><p> Here the protocol starts a frame with <code>0xdeadbeef</code>, followed by the data size, and then the data.</p>
<p><a class="el" href="class_svc_1_1_deframing_protocol.html" title="Abstract base class representing a deframing protocol.">Svc::DeframingProtocol</a> implementors need to implement one function: deframe, taking in a circular buffer supplying data, filling the needed variable, and returning a status. The base class supplies a <a href="../api/c++/html/class_svc_1_1_deframing_protocol_interface.html">DeframingProtocolInterface</a> member variable, <code>m_interface</code>, that allows implementors to call out for allocating data and routing the deframed data. A minimal implementation is:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>MyDeframeProtocol : <span class="keyword">public</span> DeframingProtocol {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    MyDeframeProtocol() {}</div>
<div class="line">    </div>
<div class="line">    DeframingProtocol::DeframingStatus deframe(<a class="code hl_class" href="class_types_1_1_circular_buffer.html">Types::CircularBuffer</a>&amp; ring, <a class="code hl_typedef" href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a>&amp; needed) {</div>
<div class="line">        <a class="code hl_typedef" href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> start = 0;</div>
<div class="line">        <a class="code hl_typedef" href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> size = 0;</div>
<div class="line">        <span class="comment">// Check for header or ask for more data</span></div>
<div class="line">        <span class="keywordflow">if</span> (ring.get_remaining_size() &lt; 8) {</div>
<div class="line">            needed = 8;</div>
<div class="line">            <span class="keywordflow">return</span> DeframingProtocol::DEFRAMING_MORE_NEEDED;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Peek into the header and read out values</span></div>
<div class="line">        (void) ring.<a class="code hl_function" href="class_types_1_1_circular_buffer.html#aec33f013e7ab72835b3d630af366ea7e">peek</a>(start, 0);</div>
<div class="line">        (void) ring.<a class="code hl_function" href="class_types_1_1_circular_buffer.html#aec33f013e7ab72835b3d630af366ea7e">peek</a>(size, 0);</div>
<div class="line">        needed = 4 + 4 + size; <span class="comment">// start + size + data</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Not enough data, call out for more</span></div>
<div class="line">        <span class="keywordflow">if</span> (ring.get_remaining_size() &lt; size) {</div>
<div class="line">            <span class="keywordflow">return</span> DeframingProtocol::DEFRAMING_MORE_NEEDED;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Protocol violation</span></div>
<div class="line">         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (start != 0xdeadbeef) {</div>
<div class="line">            <span class="keywordflow">return</span> DeframingProtocol::DEFRAMING_INVALID_CHECKSUM;</div>
<div class="line">        }</div>
<div class="line">        <a class="code hl_class" href="class_fw_1_1_buffer.html">Fw::Buffer</a> buffer = m_interface-&gt;allocate(size);</div>
<div class="line">        buffer.<a class="code hl_function" href="class_fw_1_1_buffer.html#aaccda454a4786c7d9d89c4dccc5e2c53">setSize</a>(size);</div>
<div class="line">        ring.<a class="code hl_function" href="class_types_1_1_circular_buffer.html#aec33f013e7ab72835b3d630af366ea7e">peek</a>(buffer.<a class="code hl_function" href="class_fw_1_1_buffer.html#a0f7344fefd6813ce700c7e39dfd2ce29">getData</a>(), size, 8);</div>
<div class="line">        m_interface-&gt;route(buffer);</div>
<div class="line">        <span class="keywordflow">return</span> DeframingProtocol::DEFRAMING_STATUS_SUCCESS;</div>
<div class="line">    }</div>
<div class="ttc" id="aclass_fw_1_1_buffer_html_a0f7344fefd6813ce700c7e39dfd2ce29"><div class="ttname"><a href="class_fw_1_1_buffer.html#a0f7344fefd6813ce700c7e39dfd2ce29">Fw::Buffer::getData</a></div><div class="ttdeci">U8 * getData() const</div><div class="ttdef"><b>Definition</b> <a href="_buffer_8cpp_source.html#l00068">Buffer.cpp:68</a></div></div>
<div class="ttc" id="aclass_fw_1_1_buffer_html_aaccda454a4786c7d9d89c4dccc5e2c53"><div class="ttname"><a href="class_fw_1_1_buffer.html#aaccda454a4786c7d9d89c4dccc5e2c53">Fw::Buffer::setSize</a></div><div class="ttdeci">void setSize(U32 size)</div><div class="ttdef"><b>Definition</b> <a href="_buffer_8cpp_source.html#l00087">Buffer.cpp:87</a></div></div>
<div class="ttc" id="aclass_types_1_1_circular_buffer_html"><div class="ttname"><a href="class_types_1_1_circular_buffer.html">Types::CircularBuffer</a></div><div class="ttdef"><b>Definition</b> <a href="_circular_buffer_8hpp_source.html#l00027">CircularBuffer.hpp:27</a></div></div>
<div class="ttc" id="aclass_types_1_1_circular_buffer_html_aec33f013e7ab72835b3d630af366ea7e"><div class="ttname"><a href="class_types_1_1_circular_buffer.html#aec33f013e7ab72835b3d630af366ea7e">Types::CircularBuffer::peek</a></div><div class="ttdeci">Fw::SerializeStatus peek(char &amp;value, NATIVE_UINT_TYPE offset=0) const</div><div class="ttdef"><b>Definition</b> <a href="_circular_buffer_8cpp_source.html#l00093">CircularBuffer.cpp:93</a></div></div>
</div><!-- fragment --><p> Here the protocol starts a frame with <code>0xdeadbeef</code> and uses size to extra the data. Deframing is typically the inverse of the framing protocol as seen in this example.</p>
<p>!!! note implementors should always use <code>peak</code> to get data and never rotate it, as <a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc.Deframer</a> will rotate the buffer based on the status.</p>
<h1><a class="anchor" id="autotoc_md279"></a>
Adding a Custom Driver</h1>
<p>To be compatible with this ground interface, a driver must implement the <a href="https://github.com/nasa/fprime/blob/devel/Drv/ByteStreamDriverModel/ByteStreamDriverModel.fpp">byte steam model interface</a>. The driver may add any other ports, events, telemetry, or other F´ constructs as needed but it must define the ports as described in the ByteStreamDriverModel. These ports are called out in the below FPP snippet.</p>
<div class="fragment"><div class="line">output port ready: Drv.ByteStreamReady</div>
<div class="line">guarded input port send: Drv.ByteStreamSend</div>
<div class="line"> </div>
<div class="line">output port $recv: Drv.ByteStreamRecv</div>
<div class="line">guarded input port poll: Drv.ByteStreamPoll</div>
</div><!-- fragment --><ol type="1">
<li><b>ready</b>: (output) drivers call this port without arguments to signal it is ready to receive data via the send port.</li>
<li><b>send</b>: (input) clients call this port passing in an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> to send data.</li>
<li><b>recv</b>: (output) drivers operating in asynchronous mode call this port with a RecvStatus and <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> to provide data.</li>
<li><b>poll</b>: (input) drivers operating in poll mode fill an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> and return a PollStatus to provide data. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
