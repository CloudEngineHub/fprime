<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Data Constructs: Commands, Events, Channels, and Parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">F´ Flight Software - C/C++ Documentation<span id="projectnumber">&#160;devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_fprime_2docs_2documentation_2user-manual_2overview_2cmd-evt-chn-prm.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Data Constructs: Commands, Events, Channels, and Parameters</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md381"></a></p>
<p>Typically, spacecraft software is controlled through commands and monitored using a set of events and telemetry channels. These are the critical data constructs supported directly by F´ and have built-in autocoder support. In addition, the F´ <code><a class="el" href="namespace_svc.html">Svc</a></code> components handle these types making it easy to define and control an F´ system through commands, events, and telemetry channels.</p>
<p>Parameters allow for controlling stored values that affect the operation of an F´ system. They have framework support to automatically, load, store, and set these values using commands.</p>
<p>!!! note Events are sometimes called EVRs and telemetry channels are sometimes called EHAs.</p>
<p>These types will be elaborated within this guide. It contains:</p>
<ul>
<li>Commands<ul>
<li>Command Dispatching</li>
<li>Command Sequencing</li>
</ul>
</li>
<li>Events<ul>
<li>Event Logging</li>
</ul>
</li>
<li>Channels<ul>
<li>Telemetry Database</li>
</ul>
</li>
<li>Parameters</li>
<li>A Note On Serialized Ports</li>
</ul>
<h1><a class="anchor" id="autotoc_md382"></a>
Commands</h1>
<p>Each <b>Component</b> defines a set of commands for operations. Unlike ports, which are intended for component to component communication, commands are designed for user interaction with a component. Commands are defined through a series of properties. Users can send commands to the F´ system and via <code>Svc::CmdDispatcher</code> these commands are dispatched to a handling component to invoke some behavior. The handling component handles a command by defining a command handler function to run when the command arrives.</p>
<p>The properties defining commands are shown below:</p>
<ol type="1">
<li>opcode: a numerical value uniquely representing the command. This opcode is automatically adjusted to be relative to a component's base id, and thus will not collide with other commands defined by other components.</li>
<li>mnemonic: a text value uniquely representing the command. The component instance name is prepended to the mnemonic to ensure uniqueness in the system.</li>
<li>arguments: a set of primitive and F´ data types supplied to the command handler to adjust its execution. These arguments are sent from the ground.</li>
<li>synchronization "kind": (sync, async, guarded) controls which execution context the command runs in. Sync and guarded commands run on the execution context of the command dispatcher. Async commands execute on the component threads and can specify a priority. Guarded commands are protected from reentrancy by a mutex. These are similar to <a href="port-comp-top.md#a-quick-look-at-port-kinds-defined-in-a-components-usage">port kinds</a></li>
</ol>
<p>Code in the component-specific generated base class calls a function to invoke the user-defined command handler. This is hooked up by connecting the command registration, command dispatch, and command response ports.</p>
<h2><a class="anchor" id="autotoc_md383"></a>
Command Dispatching</h2>
<p>When commands are defined for a component, the autocoder automatically adds ports for registering and receiving commands, and reporting an execution status when finished. Each component that handles commands should be hooked up to the command dispatcher connecting the registration, dispatch, and response ports in parallel.</p>
<p><img src="../../../img/data_model1.png" alt="Command Dispatcher" class="inline"/></p>
<p><b>Figure 4. Command dispatcher.</b> The command dispatcher receives the raw buffer containing the command and arguments. The command opcode is extracted, and a lookup table is used to find the handling component. The argument buffer is then passed to the component, and the command dispatcher waits without blocking for the component to return status..</p>
<p>In many projects, commands need to be sequenced in order. In order to facilitate this, the framework provides <code><a class="el" href="namespace_svc.html#a3882aff73e9796ed7b550aeb9f360f48">Svc::CmdSequencer</a></code>. The command sequencer reads a defined sequence of commands and sends each in turn to the command dispatcher; after each command is dispatched, the status of its execution is returned to the sequencer. Sending command buffers to the command dispatcher through the command sequencer is an alternate path to sending them externally from the ground.</p>
<h2><a class="anchor" id="autotoc_md384"></a>
Command Sequencing</h2>
<p><img src="../../../img/data_model2.png" alt="Command Sequencer" class="inline"/></p>
<p><b>Figure 5. Command sequence.</b> The command sequencer loads a sequence file from the file system, sends the command, and waits for the response for each command in the sequence. A failed response terminates the sequence, while a successful response moves to the next command in the sequence.</p>
<h1><a class="anchor" id="autotoc_md385"></a>
Events</h1>
<p>Events represent a log of activities taken by the embedded system. Events can be thought of in the same way as a program execution log in that they enable the ability to trace the execution of the system. Events are sent out of the system via the <code><a class="el" href="namespace_svc.html#ac0e00075604e6b204b18163442910ec1">Svc::ActiveLogger</a></code> component and components defining events should hook up the log port to it. If console logging is desired, the text log port can be hooked up to the <code>Svc::PassiveConsoleTextLogger</code> component. Events are defined per component and are typically used to capture what the component is doing. Events can occur sporadically; however, they should all be captured for downlink. Events are defined by the following properties:</p>
<ol type="1">
<li>id: a numeric id uniquely define this event. It is automatically offset by the component's base id to ensure global uniqueness.</li>
<li>name: a unique text identifier for this event. This is prepended by the component instance name to remain unique.</li>
<li>severity: a text identifier identifying the severity of this event. Possible values are:<ol type="a">
<li>DIAGNOSTIC: akin to debug messages. Usually not sent to the ground.</li>
<li>ACTIVITY_LO: akin to fine info messages these typically come from background tasks</li>
<li>ACTIVITY_HI: akin to info messages these typically come from foreground tasks</li>
<li>WARNING_LO: less severe warning events</li>
<li>WARNING_HI: high-severity warning events, although the system can still function</li>
<li>FATAL: fatal events indicating that the system <b>must</b> reboot</li>
<li>COMMAND: events tracing the execution of commands</li>
</ol>
</li>
<li>arguments: like command arguments, these are primitive and complex types that represent the variable data associated with the event. These are injected into the format string for a full text representation of the event.</li>
<li>format string: a C-style format string used to reconstruct a text version of the event.</li>
</ol>
<p>!!! note the use of events to severity levels are based on the judgement of the system designer.</p>
<p>Code in the component-specific generated base class provides a function to call to emit each event defined by the component. This function expects an argument to be supplied for each argument defined by the event. The code generator automatically adds ports for retrieving a time tag and sending events. There are two independent ports for sending events:</p>
<ol type="1">
<li>binary log output port for sending outside the system</li>
<li>a text log output port for on-board consoles</li>
</ol>
<h2><a class="anchor" id="autotoc_md386"></a>
Event Logging</h2>
<p>Events first acquire a time tag to represent when they occurred and then are typically sent to the <code><a class="el" href="namespace_svc.html#ac0e00075604e6b204b18163442910ec1">Svc::ActiveLogger</a></code> component on their way to be sent down to the ground. This logger component both processes the event and also recognizes and begins responses for FATAL severity events.</p>
<p><img src="../../../img/data_model3.png" alt="Active Logger" class="inline"/></p>
<p><b>Figure 6. Event log.</b> The component implementation calls a function to generate the event. The base class retrieves the time tag from the time source component. The component sends the event to the event log component, which reads it from the port queue and sends it to the ground.</p>
<h1><a class="anchor" id="autotoc_md387"></a>
Channels</h1>
<p>Channels, also known as Telemetry Channels, or just Telemetry, represent the current reading of some portion of the system state. This state is either restricted to "send on change" or "send per update" even if the update is already the current value. Channels are broken up per component and are typically sampled at a set rate and downlinked. Channels are id, time, and value triples and are defined per component with the following properties:</p>
<ol type="1">
<li>id: the unique id of the channel. This is offset by the base id of the component for global uniqueness.</li>
<li>name: the unique text name of the channel. This is prepended with the component instance name for global uniqueness.</li>
<li>data_type: type of the value of the channel. Can be primitive and complex types.</li>
<li>update: "on_change" to update only when the written value changes, and omitted to always downlink</li>
</ol>
<p>Code in the component-specific generated base class provides a function to call to set the current value for a channel id. This function must be supplied with a typed argument for the value. It will request the time tag internally. The code generator automatically adds ports for retrieving time tags and sending channelized data.</p>
<h2><a class="anchor" id="autotoc_md388"></a>
Telemetry Database</h2>
<p>The telemetry database acts as a double-buffered store for telemetry values. Components are free to update channels at any time; however, the current value will be read from the telemetry database and sent to the ground at a set rate. Components using this service should hook up the telemetry port to the telemetry database (<code><a class="el" href="class_svc_1_1_tlm_chan.html">Svc::TlmChan</a></code>).</p>
<p><img src="../../../img/data_model4.png" alt="Telemetry Database" class="inline"/></p>
<p><b>Figure 7. Telemetry database.</b> The telemetry database has a double-buffered array of telemetry buffers. The base class function retrieves the time tag from the time source component and then writes the updated value to the telemetry database component. The telemetry database is called periodically to send the current set of telemetry to the ground.</p>
<p>!!! note the periodic call to the telemetry database is typically made by a <a class="el" href="md_fprime_2docs_2documentation_2user-manual_2design_2rate-group.html">rate group</a>.</p>
<h1><a class="anchor" id="autotoc_md389"></a>
Parameters</h1>
<p>Parameters are traditional means of storing non-volatile states in the embedded system. The framework provides code generation to manage parameters defined by a component. Parameters are defined by the following properties:</p>
<ol type="1">
<li>id: unique id of the parameter, offset by component base id to ensure global uniqueness</li>
<li>name: unique text name of parameter prepended by component instance name for global uniqueness.</li>
<li>data type: primitive or complex types that represent the type of the value stored.</li>
<li>default value: default values are assigned in the event the parameter cannot be retrieved.</li>
</ol>
<p>The code generator automatically adds ports for retrieving parameters. During initialization, a public method in the class is called which retrieves the parameters and stores copies locally. Calls can reoccur if the parameter is updated. The code-generated base class provides a function to call for each parameter to retrieve the stored copy; and an implementation class can retrieve the value whenever the parameter value is needed.</p>
<h2><a class="anchor" id="autotoc_md390"></a>
Parameter Database</h2>
<p>The framework provides the ability to store these parameters in the parameter database (<code><a class="el" href="namespace_svc.html#ac4fe15c5a44df4ac62d4ceb2fcf6fa3e">Svc::PrmDb</a></code>). This component provides ports to get and set parameters, which are stored in a file to persist across reboots.</p>
<p><img src="../../../img/data_model5.png" alt="Parameter Database" class="inline"/></p>
<p><b>Figure 8. Parameter manager.</b> The parameter manager or database loads the file containing parameters from the file system during initialization. The initialization subsequently calls <em>loadParameters()</em> on components with parameters. Components can set and retrieve parameters. The parameter manager saves the updated values to the file system via the set and save commands auto-generated for every parameter; the set command updates the value of the parameter locally within the component that owns it, and the save command pushing the current value of the parameter to non-volatile storage, meaning it will persist within the files of the system across system resets.</p>
<h1><a class="anchor" id="autotoc_md391"></a>
A Note On Serialized Ports</h1>
<p>The <code><a class="el" href="namespace_svc.html">Svc</a></code> components use serialize ports to generically handle port data of different types to support uplink and downlink. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
