<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Dynamic Memory Allocation Using &lt;tt&gt;Fw::Buffer&lt;/tt&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">F´ Flight Software - C/C++ Documentation<span id="projectnumber">&#160;devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_fprime_2docs_2documentation_2user-manual_2framework_2dynamic-memory.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Dynamic Memory Allocation Using &lt;tt&gt;Fw::Buffer&lt;/tt&gt;</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md265"></a></p>
<p>In embedded systems, dynamic memory allocation (a.k.a heap allocation) is typically avoided to reduce the steady-state variability in a running system. Avoiding dynamic memory allocation also avoids the problem of what to do in the case of a failed allocation. However, sometimes dynamic allocation provides for a simpler or more efficient solution.</p>
<p>Safe dynamic allocation is available using the buffer manager pattern in F´. In short, this pattern allows components to dynamically allocate memory through a port call to a component designed to manage memory for the system. There are three steps in this process:</p>
<ol type="1">
<li>Call allocation port receiving an<code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code></li>
<li>Use allocated in the <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code></li>
<li>Call deallocation port providing the <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code></li>
</ol>
<h1><a class="anchor" id="autotoc_md266"></a>
Component Setup and Buffer Usage</h1>
<p>This section will describe the work done within a component to allocate, use, and deallocate buffers.</p>
<h1><a class="anchor" id="autotoc_md267"></a>
Allocating and Deallocating <code>Fw::Buffer</code>s</h1>
<p>Allocation and deallocation are done through port calls to a buffer managing component. The component needing dynamic memory allocation should include two output ports:</p>
<ol type="1">
<li>Output port of type <code>Fw::BufferGet</code> to request a buffer</li>
<li>Output port of type <code>Fw::BufferSend</code> to deallocate the requested buffer.</li>
</ol>
<p>In the case that allocation fails, the <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> return from the <code>Fw::BufferGet</code> port will have a size of zero. Developers must check that the size is not smaller than requested before proceeding to use the memory.</p>
<p>In the example below, the ports are called <code>allocate</code> and <code>deallocate</code>. First the port definitions are presented followed by the usage in C++.</p>
<p><b>Example Component Definition</b> </p><div class="fragment"><div class="line">@ Allocation port for a buffer</div>
<div class="line">output port allocate: Fw.BufferGet</div>
<div class="line"> </div>
<div class="line">@ Deallocation port for buffers</div>
<div class="line">output port deallocate: Fw.BufferSend</div>
<div class="line"> </div>
<div class="line">@ Allocation failed event</div>
<div class="line">event MemoryAllocationFailed() severity warning low id 0 format &quot;Failed to allocate memory&quot;</div>
</div><!-- fragment --><p><b>Example Component Allocation and Deallocation</b> </p><div class="fragment"><div class="line">++</div>
<div class="line">   ...</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> needed_size = 1024;</div>
<div class="line">   <a class="code hl_class" href="class_fw_1_1_buffer.html">Fw::Buffer</a> my_buffer = this-&gt;allocate_out(0, needed_size);</div>
<div class="line">   </div>
<div class="line">   <span class="keywordflow">if</span> (my_buffer.<a class="code hl_function" href="class_fw_1_1_buffer.html#a82190e37d06defba369d8c4bff9662de">getSize</a>() &lt; needed_size) {</div>
<div class="line">       this-&gt;deallocate_out(0, my_buffer);</div>
<div class="line">       this-&gt;log_WARNING_LO_MemoryAllocationFailed();</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">       ...</div>
<div class="line">       ...</div>
<div class="line">       this-&gt;deallocate_out(0, my_buffer);</div>
<div class="line">   }</div>
<div class="ttc" id="abasic__types_8h_html_a696390429f2f3b644bde8d0322a24124"><div class="ttname"><a href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a></div><div class="ttdeci">uint32_t U32</div><div class="ttdef"><b>Definition</b> <a href="basic__types_8h_source.html#l00028">basic_types.h:28</a></div></div>
<div class="ttc" id="aclass_fw_1_1_buffer_html"><div class="ttname"><a href="class_fw_1_1_buffer.html">Fw::Buffer</a></div><div class="ttdef"><b>Definition</b> <a href="_buffer_8hpp_source.html#l00043">Buffer.hpp:43</a></div></div>
<div class="ttc" id="aclass_fw_1_1_buffer_html_a82190e37d06defba369d8c4bff9662de"><div class="ttname"><a href="class_fw_1_1_buffer.html#a82190e37d06defba369d8c4bff9662de">Fw::Buffer::getSize</a></div><div class="ttdeci">U32 getSize() const</div><div class="ttdef"><b>Definition</b> <a href="_buffer_8cpp_source.html#l00072">Buffer.cpp:72</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md268"></a>
Working With F´ Buffers</h2>
<p><code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> objects function as a wrapper for generic memory regions. They consist of a pointer to memory and the size of the memory region pointed to by the pointer. An easy way to work with an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> is to use the serialization representation of the buffer. This allows users to serialize and deserialize from the buffer's data using methods.</p>
<p>To use this method, get a representation using the <code><a class="el" href="class_fw_1_1_buffer.html#af881c86bc7c3a7855009d0eb537f60d0">Fw::Buffer.getSerializeRepr()</a></code> and then call <code>.serialize()</code> or <code>.deserialize()</code> on the returned object.</p>
<p><b>Example Using Serialization and Deserialization Methods</b></p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_typedef" href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> my_value = 123;</div>
<div class="line"><a class="code hl_class" href="class_fw_1_1_buffer.html">Fw::Buffer</a> my_buffer = ...;</div>
<div class="line">my_buffer.<a class="code hl_function" href="class_fw_1_1_buffer.html#af881c86bc7c3a7855009d0eb537f60d0">getSerializeRepr</a>().<a class="code hl_function" href="class_fw_1_1_serialize_buffer_base.html#ac7eef383cbb84ad69d09d036a7249cdf">serialize</a>(mv_value);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="basic__types_8h.html#a696390429f2f3b644bde8d0322a24124">U32</a> my_value_again = 0;</div>
<div class="line">my_buffer.<a class="code hl_function" href="class_fw_1_1_buffer.html#af881c86bc7c3a7855009d0eb537f60d0">getSerializeRepr</a>().<a class="code hl_function" href="class_fw_1_1_serialize_buffer_base.html#a99f6c704e514620bf8e26dc28a6f698a">deserialize</a>(mv_value_again);</div>
<div class="ttc" id="aclass_fw_1_1_buffer_html_af881c86bc7c3a7855009d0eb537f60d0"><div class="ttname"><a href="class_fw_1_1_buffer.html#af881c86bc7c3a7855009d0eb537f60d0">Fw::Buffer::getSerializeRepr</a></div><div class="ttdeci">SerializeBufferBase &amp; getSerializeRepr()</div><div class="ttdef"><b>Definition</b> <a href="_buffer_8cpp_source.html#l00107">Buffer.cpp:107</a></div></div>
<div class="ttc" id="aclass_fw_1_1_serialize_buffer_base_html_a99f6c704e514620bf8e26dc28a6f698a"><div class="ttname"><a href="class_fw_1_1_serialize_buffer_base.html#a99f6c704e514620bf8e26dc28a6f698a">Fw::SerializeBufferBase::deserialize</a></div><div class="ttdeci">SerializeStatus deserialize(U8 &amp;val)</div><div class="ttdoc">deserialize 8-bit unsigned int</div><div class="ttdef"><b>Definition</b> <a href="_serializable_8cpp_source.html#l00302">Serializable.cpp:302</a></div></div>
<div class="ttc" id="aclass_fw_1_1_serialize_buffer_base_html_ac7eef383cbb84ad69d09d036a7249cdf"><div class="ttname"><a href="class_fw_1_1_serialize_buffer_base.html#ac7eef383cbb84ad69d09d036a7249cdf">Fw::SerializeBufferBase::serialize</a></div><div class="ttdeci">SerializeStatus serialize(U8 val)</div><div class="ttdoc">serialize 8-bit unsigned int</div><div class="ttdef"><b>Definition</b> <a href="_serializable_8cpp_source.html#l00065">Serializable.cpp:65</a></div></div>
</div><!-- fragment --><p> !!! note To use this method types must inherit from <code><a class="el" href="class_fw_1_1_serializable.html" title="forward declaration">Fw::Serializable</a></code> or be basic types.</p>
<p>Users can access the <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code>'s data directly using <code><a class="el" href="class_fw_1_1_buffer.html#a0f7344fefd6813ce700c7e39dfd2ce29">Fw::Buffer.getData()</a></code>, which will return a <code>U8*</code> pointer to the buffer's memory. Care should be taken as this is a raw pointer and thus buffer overruns are possible.</p>
<p><b>Example Using Raw Data</b></p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="class_fw_1_1_buffer.html">Fw::Buffer</a> my_buffer = ...;</div>
<div class="line"><a class="code hl_typedef" href="_basic_types_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a>* <span class="keyword">const</span> data = my_buffer.<a class="code hl_function" href="class_fw_1_1_buffer.html#a0f7344fefd6813ce700c7e39dfd2ce29">getData</a>();</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="_assert_8hpp.html#ae203ae2022a5f92eea0ceb85a0d62c3c">FW_ASSERT</a>(my_buffer.<a class="code hl_function" href="class_fw_1_1_buffer.html#a82190e37d06defba369d8c4bff9662de">getSize</a>() &gt;= 4); <span class="comment">// Prevent overrun on next line</span></div>
<div class="line">data[3] = 1;</div>
<div class="ttc" id="a_assert_8hpp_html_ae203ae2022a5f92eea0ceb85a0d62c3c"><div class="ttname"><a href="_assert_8hpp.html#ae203ae2022a5f92eea0ceb85a0d62c3c">FW_ASSERT</a></div><div class="ttdeci">#define FW_ASSERT(...)</div><div class="ttdef"><b>Definition</b> <a href="_assert_8hpp_source.html#l00014">Assert.hpp:14</a></div></div>
<div class="ttc" id="a_basic_types_8h_html_aa63ef7b996d5487ce35a5a66601f3e73"><div class="ttname"><a href="_basic_types_8h.html#aa63ef7b996d5487ce35a5a66601f3e73">U8</a></div><div class="ttdeci">uint8_t U8</div><div class="ttdoc">8-bit unsigned integer</div><div class="ttdef"><b>Definition</b> <a href="_basic_types_8h_source.html#l00026">BasicTypes.h:26</a></div></div>
<div class="ttc" id="aclass_fw_1_1_buffer_html_a0f7344fefd6813ce700c7e39dfd2ce29"><div class="ttname"><a href="class_fw_1_1_buffer.html#a0f7344fefd6813ce700c7e39dfd2ce29">Fw::Buffer::getData</a></div><div class="ttdeci">U8 * getData() const</div><div class="ttdef"><b>Definition</b> <a href="_buffer_8cpp_source.html#l00068">Buffer.cpp:68</a></div></div>
</div><!-- fragment --><p>Full <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> documentation is available <a href="../api/c++/html/class_fw_1_1_buffer.html">here</a>.</p>
<h1><a class="anchor" id="autotoc_md269"></a>
Topology Consideration</h1>
<p>There are several components designed to allow for memory allocation and they differ in terms of complexity and use cases. They both support the <code>Fw::BufferGet</code> and <code>Fw::BufferSend</code> port interface for allocation and deallocation and thus can be used interchangeably subject to the descriptions in this section.</p>
<p>Each section will describe any special setup needed in the topology and how to hook up the manager's ports.</p>
<h2><a class="anchor" id="autotoc_md270"></a>
Svc.StaticMemory</h2>
<p><a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a> uses a stack-based pool of memory to support allocation. This pool is composed of fixed-size regions each of which is tied to a specific client. Each client's allocation <b>must</b> be deallocated before a subsequent request by the same client. Since allocation and deallocation ports are port arrays, each client's allocation and deallocation ports must be hooked up in parallel.</p>
<p>This component is designed for simplicity of implementation. System memory usage is <b>always</b> the number of clients multiplied by the size of the memory regions. This memory is allocated as a large array on the stack. Valid memory allocations will always be returned or a software error will be tripped.</p>
<p><a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a> is described in more detail <a href="../api/c++/html/svc_static_memory_component.html">here</a>.</p>
<p><b>When To Use <a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a></b></p>
<p>Use <a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a> in situations where memory must always be available and sharing or efficient use of memory is a concern. <a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a> is typically not suitable for situations where asynchronous memory handling occurs between allocation and deallocation.</p>
<p><em><b>Usage Requirements</b></em></p>
<p>Since this component is designed to be simple, its usage has several caveats. These caveats are, for the most part, enforced by assertions, and thus failure to abide by them will result in software termination.</p>
<ol type="1">
<li>Allocations will always return with the size of <code><a class="el" href="namespace_svc.html#ad27f471a5a849fa12cbd97a3cecfa625a9e9672fa96e8a1d300d3756c6d5c1e24">Svc::StaticMemoryConfig::STATIC_MEMORY_ALLOCATION_SIZE</a></code></li>
<li>Allocations above <code><a class="el" href="namespace_svc.html#ad27f471a5a849fa12cbd97a3cecfa625a9e9672fa96e8a1d300d3756c6d5c1e24">Svc::StaticMemoryConfig::STATIC_MEMORY_ALLOCATION_SIZE</a></code> is considered an error</li>
<li>It is an error for a client to allocate memory before deallocating previously allocated memory</li>
</ol>
<p>These rules imply that memory allocated from <a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a> should never be sent through an asynchronous port as this will risk violating item 3.</p>
<p><b>Connections</b></p>
<p>All connections to <a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a> are done using parallel port indices per-client. This is shown in the Topology snippet shown below:</p>
<div class="fragment"><div class="line">client1.allocate -&gt; my_static_memory.bufferAllocate[0]</div>
<div class="line">client1.deallocate -&gt; my_static_memory.bufferDeallocate[0]</div>
<div class="line"> </div>
<div class="line">client2.allocate -&gt; my_static_memory.bufferAllocate[1]</div>
<div class="line">client2.deallocate -&gt; my_static_memory.bufferDeallocate[1]</div>
</div><!-- fragment --><p><a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a> does not use any other ports. Please review the configuration to ensure that sufficient regions are available for the number of clients used.</p>
<p><em><b>Configuration and Setup</b></em></p>
<p>Allocation region size is configured in the <code><a class="el" href="_static_memory_config_8hpp.html">StaticMemoryConfig.hpp</a></code> header using the <code>STATIC_MEMORY_ALLOCATION_SIZE</code> value and maximum client number is configured in <code>AcConstants.fpp</code> using the <code>StaticMemoryAllocations</code> value. No other configuration or setup is necessary.</p>
<h2><a class="anchor" id="autotoc_md271"></a>
Svc.BufferManager</h2>
<p><a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a> uses multiple bins of memory with fixed-size sub-allocations within a bin. It has a single allocate and deallocate port that may take any size allocation request. <a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a> searches all bins with sub-allocation size larger than the request for an available buffer, which it then marks as used and returns.</p>
<p>There is no restriction on the ordering of calls for allocation and deallocation. Clients may have multiple outstanding allocations and thus asynchronous usage of these allocations is supported.</p>
<p><a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a> is described in more detail <a href="../api/c++/html/svc_buffer_manager_component.html">here</a>.</p>
<p><b>When To Use <a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a></b></p>
<p><a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a> must be used when asynchronous handling of memory is needed or sharing of memory is desired. It can be used generically but comes at the cost of complexity of implementation and setup.</p>
<p><b>Usage Requirements</b></p>
<p>Allocating more memory than available will result in buffers with size 0 being returned and is not an error. However, buffers must be allocated and returned using the same instance of <a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a>.</p>
<p>Buffer manager will assert under the following conditions:</p><ol type="1">
<li>A returned buffer has the incorrect manager ID (returned to the wrong instance).</li>
<li>A returned buffer has an incorrect buffer ID (invalid buffer returned).</li>
<li>A returned buffer is returned with a correct buffer ID but hasn't already been allocated.</li>
<li>A returned buffer has an indicated size larger than originally allocated.</li>
<li>A returned buffer has a pointer outside the region originally allocated.</li>
</ol>
<p><b>Connections</b></p>
<p>All connections to <a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a> can be done using the single pair of allocate and deallocate ports. This is shown in the following snippet of a topology:</p>
<div class="fragment"><div class="line">client1.allocate -&gt; my_buffer_manager.bufferGetCallee</div>
<div class="line">client1.deallocate -&gt; my_buffer_manager.bufferSendIn</div>
<div class="line"> </div>
<div class="line">client2.allocate -&gt; my_buffer_manager.bufferGetCallee</div>
<div class="line">client2.deallocate -&gt; my_buffer_manager.bufferSendIn</div>
</div><!-- fragment --><p>The buffer manager should also be hooked up to a rate group used to downlink telemetry and it requires standard telemetry, events, and time connections.</p>
<p><b>Configuration and Setup</b></p>
<p>The number of sub allocations is configured in the <code><a class="el" href="_buffer_manager_component_impl_cfg_8hpp.html">BufferManagerComponentImplCfg.hpp</a></code> header using the <code>BUFFERMGR_MAX_NUM_BINS</code> value.</p>
<p>When using <a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a> the <code><a class="el" href="class_svc_1_1_buffer_manager_component_impl.html#a3c39e3a9da3d100d3b6ee4babef86f63" title="set up configuration">Svc::BufferManagerComponentImpl.setup()</a></code> method must be called supplying a U16 manager ID, a buffer id, an implementation of <a href="../api/c++/html/class_fw_1_1_mem_allocator.html">Fw::MemAllocator</a> used to allocate memory for the sub-allocations, and a <a href="../api/c++/html/struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin.html">Svc::BufferManagerComponentImpl::BufferBins</a> struct configuring the sub allocations.</p>
<p>The <a class="el" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins.html">Svc::BufferManagerComponentImpl::BufferBins</a> is a table specifying N buffers of M size per bin. Up to MAX_NUM_BINS bins can be specified. The table is copied when setup() is called, so it does not need to be retained after the call.</p>
<p>The rules for specifying bins:</p><ol type="1">
<li>For each bin (BufferBins.bins[n]), specify the size of the buffers (bufferSize) in the bin and how many buffers for that bin (numBuffers).</li>
<li>The bins must be ordered based on an increasing bufferSize to allow BufferManager to search for available buffers. When receiving a request for a buffer, the component will search for the first buffer from the bins that are equal to or greater than the requested size, starting at the beginning of the table.</li>
<li>Any unused bins should have numBuffers set to 0.</li>
<li>A single bin can be specified if a single size is needed.</li>
</ol>
<p>!!! note a pointer to the <a class="el" href="class_fw_1_1_mem_allocator.html">Fw::MemAllocator</a> used in setup() is stored for later memory cleanup. The instance of the allocator must persist beyond calling the cleanup() function or the destructor of BufferManager if cleanup() is not called. If a project-specific manual memory allocator is not needed, <a class="el" href="class_fw_1_1_malloc_allocator.html">Fw::MallocAllocator</a> can be used to supply heap allocated memory.</p>
<p><b>Example Setup of <a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a></b> </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="class_fw_1_1_malloc_allocator.html">Fw::MallocAllocator</a> allocator;</div>
<div class="line"><a class="code hl_class" href="class_svc_1_1_buffer_manager_component_impl.html">Svc::BufferManagerComponentImpl</a> my_buffer_manager;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins.html">Svc::BufferManager::BufferBins</a> my_bins;</div>
<div class="line">    memset(&amp;my_bins, 0, <span class="keyword">sizeof</span>(my_bins)); <span class="comment">// All non-specified bins are zero</span></div>
<div class="line"> </div>
<div class="line">    my_bins.<a class="code hl_variable" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins.html#a27d6878d2eebf656b07dad9ff114174d">bins</a>[0].<a class="code hl_variable" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin.html#a8a68343765704783d1b46a0706933e6d">bufferSize</a> = 1024; <span class="comment">// Buffers in bin 0 are of size 1024</span></div>
<div class="line">    my_bins.<a class="code hl_variable" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins.html#a27d6878d2eebf656b07dad9ff114174d">bins</a>[0].<a class="code hl_variable" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin.html#a1edb07f3f43c9403e0e6155fb7ebbec2">numBuffers</a> = 2; <span class="comment">// Two buffers of size 1024 are available in bin 0</span></div>
<div class="line">    my_bins.<a class="code hl_variable" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins.html#a27d6878d2eebf656b07dad9ff114174d">bins</a>[1].<a class="code hl_variable" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin.html#a8a68343765704783d1b46a0706933e6d">bufferSize</a> = 10240; <span class="comment">// Buffers in bin 1 are of size 10240</span></div>
<div class="line">    my_bins.<a class="code hl_variable" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins.html#a27d6878d2eebf656b07dad9ff114174d">bins</a>[1].<a class="code hl_variable" href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin.html#a1edb07f3f43c9403e0e6155fb7ebbec2">numBuffers</a> = 1; <span class="comment">// One buffers of size 10240 are available in bin 1</span></div>
<div class="line">    </div>
<div class="line">    my_buffer_manager.<a class="code hl_function" href="class_svc_1_1_buffer_manager_component_impl.html#a3c39e3a9da3d100d3b6ee4babef86f63">setup</a>(123, 0, allocator, my_bins);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">{</div>
<div class="line">    my_buffer_manager.<a class="code hl_function" href="class_svc_1_1_buffer_manager_component_impl.html#a360e4d0a7c374c2407252ab8d96077bd">cleanup</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_fw_1_1_malloc_allocator_html"><div class="ttname"><a href="class_fw_1_1_malloc_allocator.html">Fw::MallocAllocator</a></div><div class="ttdef"><b>Definition</b> <a href="_malloc_allocator_8hpp_source.html#l00029">MallocAllocator.hpp:29</a></div></div>
<div class="ttc" id="aclass_svc_1_1_buffer_manager_component_impl_html"><div class="ttname"><a href="class_svc_1_1_buffer_manager_component_impl.html">Svc::BufferManagerComponentImpl</a></div><div class="ttdef"><b>Definition</b> <a href="_buffer_manager_component_impl_8hpp_source.html#l00056">BufferManagerComponentImpl.hpp:57</a></div></div>
<div class="ttc" id="aclass_svc_1_1_buffer_manager_component_impl_html_a360e4d0a7c374c2407252ab8d96077bd"><div class="ttname"><a href="class_svc_1_1_buffer_manager_component_impl.html#a360e4d0a7c374c2407252ab8d96077bd">Svc::BufferManagerComponentImpl::cleanup</a></div><div class="ttdeci">void cleanup()</div><div class="ttdef"><b>Definition</b> <a href="_buffer_manager_component_impl_8cpp_source.html#l00061">BufferManagerComponentImpl.cpp:62</a></div></div>
<div class="ttc" id="aclass_svc_1_1_buffer_manager_component_impl_html_a3c39e3a9da3d100d3b6ee4babef86f63"><div class="ttname"><a href="class_svc_1_1_buffer_manager_component_impl.html#a3c39e3a9da3d100d3b6ee4babef86f63">Svc::BufferManagerComponentImpl::setup</a></div><div class="ttdeci">void setup(NATIVE_UINT_TYPE mgrID, NATIVE_UINT_TYPE memID, Fw::MemAllocator &amp;allocator, const BufferBins &amp;bins)</div><div class="ttdoc">set up configuration</div><div class="ttdef"><b>Definition</b> <a href="_buffer_manager_component_impl_8cpp_source.html#l00167">BufferManagerComponentImpl.cpp:167</a></div></div>
<div class="ttc" id="astruct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin_html_a1edb07f3f43c9403e0e6155fb7ebbec2"><div class="ttname"><a href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin.html#a1edb07f3f43c9403e0e6155fb7ebbec2">Svc::BufferManagerComponentImpl::BufferBin::numBuffers</a></div><div class="ttdeci">NATIVE_UINT_TYPE numBuffers</div><div class="ttdoc">number of buffers in this bin. Set to zero for unused bins.</div><div class="ttdef"><b>Definition</b> <a href="_buffer_manager_component_impl_8hpp_source.html#l00081">BufferManagerComponentImpl.hpp:81</a></div></div>
<div class="ttc" id="astruct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin_html_a8a68343765704783d1b46a0706933e6d"><div class="ttname"><a href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bin.html#a8a68343765704783d1b46a0706933e6d">Svc::BufferManagerComponentImpl::BufferBin::bufferSize</a></div><div class="ttdeci">NATIVE_UINT_TYPE bufferSize</div><div class="ttdoc">size of the buffers in this bin. Set to zero for unused bins.</div><div class="ttdef"><b>Definition</b> <a href="_buffer_manager_component_impl_8hpp_source.html#l00080">BufferManagerComponentImpl.hpp:80</a></div></div>
<div class="ttc" id="astruct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins_html"><div class="ttname"><a href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins.html">Svc::BufferManagerComponentImpl::BufferBins</a></div><div class="ttdef"><b>Definition</b> <a href="_buffer_manager_component_impl_8hpp_source.html#l00085">BufferManagerComponentImpl.hpp:86</a></div></div>
<div class="ttc" id="astruct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins_html_a27d6878d2eebf656b07dad9ff114174d"><div class="ttname"><a href="struct_svc_1_1_buffer_manager_component_impl_1_1_buffer_bins.html#a27d6878d2eebf656b07dad9ff114174d">Svc::BufferManagerComponentImpl::BufferBins::bins</a></div><div class="ttdeci">BufferBin bins[BUFFERMGR_MAX_NUM_BINS]</div><div class="ttdoc">set of bins to define buffers</div><div class="ttdef"><b>Definition</b> <a href="_buffer_manager_component_impl_8hpp_source.html#l00087">BufferManagerComponentImpl.hpp:87</a></div></div>
</div><!-- fragment --><p><b>Rules of Thumb for Bin Sizes</b></p>
<p>Buffers bins should be tailored based on expected usage. If many small requests are expected, then set up a large number of smaller bins. If larger allocations are expected, set bins of that size.</p>
<p>The above trivial example allows for a few small allocations and one large allocation. In this case, there is a risk that the large allocation is used for the small allocation use case and thus care should be taken to ensure that the smaller use cases have a sufficient number of buffers to prevent stealing of larger allocations.</p>
<h1><a class="anchor" id="autotoc_md272"></a>
Separation of <code>Fw::Buffer</code> Allocation and Deallocation</h1>
<p>There is no requirement that the allocating component and the deallocating component are the same. Thus components may be chained together for multiple processing steps before deallocation. There are two requirements:</p>
<ol type="1">
<li><code>Fw::Buffers</code> must eventually be returned to the instance that allocated them</li>
<li><code><a class="el" href="namespace_svc.html#ae0dd31d08e2d4a55709aff6caa18ace6">Svc.StaticMemory</a></code> cannot be used in chains involving asynchronous calls</li>
</ol>
<p>Inter-component connections typically use the same <code>Fw.BufferSend</code> port to pass the buffer along the chain. A sample chain is shown here using <a class="el" href="namespace_svc.html#a3cd251693b4a0d77eb953f6dd9c049e9">Svc.BufferManager</a> as the allocation source.</p>
<div class="fragment"><div class="line">comp1.allocate -&gt; my_buffer_manager.bufferGetCallee</div>
<div class="line">comp1.sendToProcess -&gt; comp2.process</div>
<div class="line">comp2.sendToProcessMore -&gt; comp3.processMore</div>
<div class="line">comp3.deallocate -&gt; my_buffer_manager.bufferSendIn</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
